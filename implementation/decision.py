"""
Decision-making logic for the assistive robot.

This file can be auto-generated by the Parameter Tuning GUI.
Parameters are loaded from config/default_params.yml.
"""

from core.actions import Action
from core.state import RobotState
from core.constraints import is_action_allowed
from config.loader import PARAMS, get_risk_buffer

# TUNED PARAMETERS (loaded from config)
RECHARGE_THRESHOLD = PARAMS['recharge_threshold']
CRITICAL_BATTERY = PARAMS['critical_battery']
HELP_MIN_BATTERY = PARAMS['help_min_battery']
PROACTIVE_RECHARGE = PARAMS['proactive_recharge']
RISK_BUFFER = get_risk_buffer(PARAMS['risk_tolerance'])


def choose_action(state: RobotState) -> Action:
    """
    Choose the best action based on tuned parameters.
    
    This implementation uses parameters tuned via the GUI to make decisions.
    """
    
    # Rule 1: Critical battery - must recharge or call for help
    if state.battery < CRITICAL_BATTERY:
        if state.user_urgency >= 3 and state.battery >= 10:
            return Action.HELP_USER
        elif state.battery >= 10:
            return Action.RECHARGE
        else:
            return Action.CALL_FOR_HELP
    
    # Rule 2: High urgency - help if we have enough battery
    if state.user_urgency >= 2 and state.battery >= HELP_MIN_BATTERY:
        return Action.HELP_USER
    
    # Rule 3: Battery below threshold - recharge
    if state.battery < RECHARGE_THRESHOLD * RISK_BUFFER:
        if PROACTIVE_RECHARGE or state.user_urgency == 0:
            return Action.RECHARGE
    
    # Rule 4: Any urgency with decent battery - help
    if state.user_urgency >= 1 and state.battery >= HELP_MIN_BATTERY:
        return Action.HELP_USER
    
    # Rule 5: No urgency - maintain battery
    if state.battery < RECHARGE_THRESHOLD:
        return Action.RECHARGE
    
    # Default - wait
    return Action.WAIT


def evaluate_options(state: RobotState) -> dict[Action, float]:
    """Evaluate all actions and return their scores."""
    # Could implement scoring here if needed
    return {}
